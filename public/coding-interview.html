<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coding Interview Preparation</title>
  <link rel="stylesheet" href="coding-interview.css">
</head>
<body>

  <!-- Navigation Menu -->
  <nav class="main-nav">
    <ul>
      <li class="nav-item"><a href="index.html">Home</a></li>
      <li class="nav-item"><a href="internship-job.html">Back to Internship & Job Preparation</a></li>
    </ul>
  </nav>

  <!-- Main Content for Coding Interview Preparation -->
  <main class="main-content">
    <section class="content-section">
      <div class="title-container">
        <h1>Coding Interview Preparation</h1>
        <p>Master key concepts, strategies, and practical steps to excel in technical interviews.</p>
      </div>

      <div class="details-container">
        <!-- Section: Popular Coding Platforms -->
        <h2>Popular Coding Platforms</h2>
        <ul>
          <li><strong>LeetCode:</strong> Solve problems sorted by difficulty and company-specific questions.</li>
          <li><strong>HackerRank:</strong> Practice coding challenges in various languages and domains.</li>
          <li><strong>Codeforces:</strong> Participate in timed contests to improve problem-solving speed.</li>
          <li><strong>GeeksforGeeks:</strong> Read in-depth articles on data structures, algorithms, and coding patterns.</li>
        </ul>

        <!-- Section: Key Interview Concepts -->
        <h2>Key Interview Concepts</h2>
        <ul>
          <li><strong>Data Structures:</strong> Arrays, Linked Lists, Stacks, Queues, Hash Tables, Trees, Graphs.</li>
          <li><strong>Algorithms:</strong> Sorting, Searching, Dynamic Programming, Backtracking, Greedy algorithms.</li>
          <li><strong>Big-O Analysis:</strong> Understand time and space complexity to optimize solutions.</li>
          <li><strong>System Design:</strong> For senior roles, practice designing scalable systems.</li>
        </ul>

        <!-- Section: Example Problem Workflow -->
        <h2>Example Problem Workflow</h2>
        <p class="indented">Here’s a step-by-step guide for solving a coding problem during an interview:</p>
        <ul>
          <li><strong>Understand the Problem:</strong> Clarify all requirements and constraints.</li>
          <li><strong>Plan the Solution:</strong> Explain your approach to the interviewer, and write pseudocode.</li>
          <li><strong>Implement the Code:</strong> Write clean, modular code while explaining each step.</li>
          <li><strong>Test Your Code:</strong> Use example and edge cases to validate your solution.</li>
          <li><strong>Optimize:</strong> Discuss possible improvements in time or space complexity.</li>
        </ul>

        <!-- Section: Strategies for Success -->
        <h2>Strategies for Success</h2>
        <ul>
          <li><strong>Practice Daily:</strong> Solve at least one coding problem every day to build muscle memory.</li>
          <li><strong>Focus on Weak Areas:</strong> Identify and improve areas where you struggle the most.</li>
          <li><strong>Mock Interviews:</strong> Simulate real interview scenarios using platforms like Pramp or with friends.</li>
          <li><strong>Learn Common Patterns:</strong> Understand common problem-solving patterns like sliding windows, divide-and-conquer, etc.</li>
        </ul>

        <!-- Section: Sample Problem -->
        <h2>Sample Problems</h2>
        <div class="problem-container">

        <!-- Sample Problem #1: Two Sum -->
        <div class="problem">
        <h3 class="problem-title" onclick="toggleProblem('problem1')">Sample Problem #1: Two Sum</h3>
        <div id="problem1" class="problem-details">

        <p class="indented"><strong>Problem:</strong> Given an array of integers, return indices of the two numbers such that they add up to a target.</p>
        <p class="indented"><strong>Example:</strong></p>
        <pre>
        Input: nums = [2, 7, 11, 15], target = 9
        Output: [0, 1]
        Explanation: nums[0] + nums[1] = 2 + 7 = 9
        </pre>

        <p class="indented"><strong>Approach:</strong> We solve this problem using a hash map to track seen numbers and their indices for efficient lookups.</p>

        <h4 class="indented-guide">Step-by-Step Guide to Solving</h4>
        <ul>
            <ul>
                <li>We need to find two numbers in the array that sum up to the target value.</li>
                <li>Return their indices, not the numbers themselves.</li>
                <li>The problem guarantees there is exactly one solution.</li>
                <li>Example Input: nums = [2, 7, 11, 15], target = 9.</li>
              </ul>
            </li>
            <li><strong>Plan the Solution:</strong>
              <ul>
                <li>Iterate through the array while maintaining a hash map of seen numbers.</li>
                <li>For each number:</li>
                <ul>
                  <li>Calculate the complement as `target - num`.</li>
                  <li>Check if the complement exists in the hash map.</li>
                  <li>If found, return the indices of the complement and the current number.</li>
                  <li>If not, store the current number in the hash map.</li>
                </ul>
              </ul>
            </li>
          </ul>
        <pre>
        def two_sum(nums, target):
            num_map = {}  # Hash map to store numbers and their indices
            for i, num in enumerate(nums):
                complement = target - num  # Calculate complement
                if complement in num_map:  # Check if complement exists
                    return [num_map[complement], i]  # Return indices
                num_map[num] = i  # Store the current number
        </pre>

        <ul>
            <li><strong>Test the Code:</strong></li>
            <ul>
              <li>Input: nums = [2, 7, 11, 15], target = 9 -> Output: [0, 1]</li>
              <li>Input: nums = [3, 2, 4], target = 6 -> Output: [1, 2]</li>
              <li>Input: nums = [3, 3], target = 6 -> Output: [0, 1]</li>
              <li>Edge Cases:</li>
              <ul>
                <li>Array with negative numbers.</li>
                <li>Array with duplicate numbers.</li>
              </ul>
            </ul>
          </ul>          

        <li><strong>Optimize:</strong>
            <ul>
                <li>Time Complexity: O(n) because each lookup and insertion in the hash map is O(1).</li>
                <li>Space Complexity: O(n) for storing the hash map.</li>
            </ul>
        </li>
    </div>
    </div>
        <!-- Sample Problem #2: Valid Parenthesis -->
        <div class="problem">
        <h3 class="problem-title" onclick="toggleProblem('problem2')">Sample Problem #2: Valid Parentheses</h3>
        <div id="problem2" class="problem-details">
        <p class="indented"><strong>Problem:</strong> Merge two sorted linked lists and return it as a single sorted list.</p>
        <p class="indented"><strong>Example:</strong></p>
        <pre>
        Input: l1 = [1,2,4], l2 = [1,3,4]
        Output: [1,1,2,3,4,4]
        </pre>

        <p class="indented"><strong>Approach:</strong> Use a dummy node to simplify the merging process, attaching nodes from the input lists in sorted order.</p>

        <h4 class="indented-guide">Step-by-Step Guide to Solving</h4>
        <ul>
            <li><strong>Understand the Problem:</strong>
              <ul>
                <li>Combine two already sorted lists into a single sorted list.</li>
                <li>Example Input: l1 = [1, 2, 4], l2 = [1, 3, 4].</li>
                <li>Output: [1, 1, 2, 3, 4, 4].</li>
              </ul>
            </li>
          
            <li><strong>Plan the Solution:</strong>
              <ul>
                <li>Use a dummy node to serve as the starting point.</li>
                <li>Use a pointer to track the last node in the merged list.</li>
                <li>Compare the heads of both lists and attach the smaller node to the merged list.</li>
                <li>Move the pointer in the list from which the smaller node was taken.</li>
                <li>When one list is exhausted, attach the remainder of the other list.</li>
              </ul>
            </li>
          </ul>
          
        <pre>
        class ListNode:
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next

        def merge_two_lists(l1, l2):
            dummy = ListNode(0)
            current = dummy

            while l1 and l2:
                if l1.val < l2.val:
                    current.next = l1
                    l1 = l1.next
                else:
                    current.next = l2
                    l2 = l2.next
                current = current.next

            current.next = l1 or l2  # Attach remaining nodes
            return dummy.next
        </pre>

        <ul>
            <li><strong>Test the Code:</strong></li>
            <ul>
              <li>Input: s = "()[]{}" -> Output: true</li>
              <li>Input: s = "(]" -> Output: false</li>
              <li>Input: s = "([)]" -> Output: false</li>
              <li>Edge Cases:</li>
              <ul>
                <li>Empty string -> Valid</li>
                <li>Only opening brackets -> Invalid</li>
                <li>Only closing brackets -> Invalid</li>
              </ul>
            </ul>
          </ul>                  

        <li><strong>Optimize:</strong>
            <ul>
                <li>Time Complexity: O(n + m), where n and m are the lengths of the input lists.</li>
                <li>Space Complexity: O(1) as it’s an in-place operation.</li>
            </ul>
        </li>
</div>
</div>

        <!-- Sample Problem #3:  Merge Two Sorted Lists -->
        <div class="problem">
        <h3 class="problem-title" onclick="toggleProblem('problem3')">Sample Problem #3:  Merge Two Sorted Lists</h3>
        <div id="problem3" class="problem-details">
        <p class="indented"><strong>Problem:</strong> Merge two sorted linked lists and return it as a single sorted list.</p>
        <p class="indented"><strong>Example:</strong></p>
        <pre>
        Input: l1 = [1,2,4], l2 = [1,3,4]
        Output: [1,1,2,3,4,4]
        </pre>

        <p class="indented"><strong>Approach:</strong> Use a dummy node to simplify the merging process, attaching nodes from the input lists in sorted order.</p>

        <h4 class="indented-guide">Step-by-Step Guide to Solving</h4>
        <ul>
            <li><strong>Understand the Problem:</strong>
              <ul>
                <li>Combine two already sorted lists into a single sorted list.</li>
                <li>Example Input: l1 = [1, 2, 4], l2 = [1, 3, 4].</li>
                <li>Output: [1, 1, 2, 3, 4, 4].</li>
              </ul>
            </li>
          
            <li><strong>Plan the Solution:</strong>
              <ul>
                <li>Use a dummy node to serve as the starting point.</li>
                <li>Use a pointer to track the last node in the merged list.</li>
                <li>Compare the heads of both lists and attach the smaller node to the merged list.</li>
                <li>Move the pointer in the list from which the smaller node was taken.</li>
                <li>When one list is exhausted, attach the remainder of the other list.</li>
              </ul>
            </li>
          </ul>          

        <pre>
        class ListNode:
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next

        def merge_two_lists(l1, l2):
            dummy = ListNode(0)
            current = dummy

            while l1 and l2:
                if l1.val < l2.val:
                    current.next = l1
                    l1 = l1.next
                else:
                    current.next = l2
                    l2 = l2.next
                current = current.next

            current.next = l1 or l2  # Attach remaining nodes
            return dummy.next
        </pre>
        <ul>
            <li><strong>Test the Code:</strong></li>
            <ul>
              <li>Input: l1 = [1, 2, 4], l2 = [1, 3, 4] -> Output: [1, 1, 2, 3, 4, 4]</li>
              <li>Input: l1 = [], l2 = [0] -> Output: [0]</li>
              <li>Input: l1 = [], l2 = [] -> Output: []</li>
              <li>Edge Cases:</li>
              <ul>
                <li>One list is empty, the other is non-empty.</li>
                <li>Both lists are empty.</li>
              </ul>
            </ul>
          </ul>
          
          <li><strong>Optimize:</strong>
            <ul>
              <li>Time Complexity: O(n + m), where n and m are the lengths of the input lists.</li>
              <li>Space Complexity: O(1) as it’s an in-place operation.</li>
            </ul>
          </li>
</div>
</div>
        <!-- Section: Additional Resources -->
        <h2>Additional Resources</h2>
        <ul>
          <li><a href="https://leetcode.com/" target="_blank">LeetCode</a>: Practice with hundreds of problems.</li>
          <li><a href="https://interviewing.io/" target="_blank">Interviewing.io</a>: Mock interviews with feedback.</li>
          <li><a href="https://systeminterview.com/" target="_blank">System Design Interview</a>: For advanced system design prep.</li>
          <li><a href="https://pramp.com/" target="_blank">Pramp</a>: Free peer-to-peer mock interviews.</li>
        </ul>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <p>&copy; 2024 Hunter College CS Handbook. All rights reserved.</p>
  </footer>

  <script src="coding-interview.js"></script>

</body>
</html>
